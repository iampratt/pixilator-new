---
alwaysApply: true
---

# ðŸš€ Full-Stack AI Image Generator To-Do List (Resume-Boosting Edition)

This checklist covers the development of a cost-optimized, full-stack generative AI application, designed to showcase advanced skills in AI, system architecture, and DevOps.

## Phase 1: Infrastructure & Setup (Cost-Free)

- [ ] **1.1. Hosting Setup:** Select and configure free-tier hosting:
  - [ ] Frontend: Vercel or Netlify (for static site + built-in CDN).
  - [ ] Backend: Serverless Functions (Vercel/Netlify Functions).
- [ ] **1.2. Database:** Set up a free-tier PostgreSQL instance using **Supabase** to handle user data and history.
- [ ] **1.3. AI API Keys:** Obtain free-tier keys/endpoints:
  - [ ] Stable Diffusion (Image Generation).
  - [ ] LLaMA-2/Mistral via Hugging Face Inference API (Prompt Refinement).
- [x] **1.4. Version Control:** Initialize a Git repository and push the base project structure to GitHub.

## Phase 2: Backend Development (AI & API Orchestration)

- [x] **2.1. Core API Endpoint:** Create a serverless function (`/api/generate`) to manage the entire workflow.
- [x] **2.2. Prompt Refinement Logic:** Implement the first LLM call:
  - [x] Function accepts user's short prompt.
  - [x] Calls LLM to **refine and expand** the short prompt into a detailed, high-quality prompt.
- [x] **2.3. Negative Prompt Automation (Advanced AI Feature):**
  - [x] Integrate a secondary LLM call or custom logic to **automatically generate a negative prompt** based on the desired style.
- [x] **2.4. Image Generation:** Integrate the Stable Diffusion API call using the refined prompt and the new negative prompt.
- [ ] **2.5. Asynchronous Job Processing (Scalability Feature):**
  - [ ] Refactor the image generation logic to run asynchronously.
  - [ ] Implement a **polling mechanism** in the serverless function to check job status and retrieve the result.
- [x] **2.6. Storage Integration:**
  - [x] After successful generation, upload the final image to a free cloud storage solution (e.g., Cloudinary Free Tier or Supabase Storage).
  - [x] Save the **image URL, positive prompt, and negative prompt** to the Supabase database.
- [x] **2.7. Rate Limiting:** Implement basic API rate limiting on the serverless endpoint to prevent abuse and stay within free-tier limits.

## Phase 3: Frontend Development (UI/UX & User Features)

- [x] **3.1. Basic UI:** Build the core input form and image display area.
- [x] **3.2. Style Customization (AI Feature):**
  - [x] Add controls for the user to select **model version, aspect ratio, and style presets** (e.g., "Cinematic," "Vaporwave").
  - [x] Pass these parameters to the backend API.
- [x] **3.3. User Authentication:** Implement secure **User Login/Registration** using Supabase Auth.
- [x] **3.4. History & Persistence (System Design Feature):**
  - [x] Create a dedicated "History" page/section.
  - [x] Fetch and display the user's previously generated images and their full metadata (prompts, settings) from the Supabase database.
- [x] **3.5. Caching Strategy:** Implement **Client-side LocalStorage** to cache the results of the last 5-10 generations locally, reducing redundant API calls.

## Phase 4: Professionalism & DevOps

- [x] **4.1. Unit Testing:** Write and commit unit tests for critical functions:
  - [x] Prompt refinement/expansion logic.
  - [x] API payload construction.
- [x] **4.2. Error Handling:** Implement robust, user-facing error handling:
  - [x] Server: Catch and log specific API errors (e.g., "rate limit exceeded," "invalid prompt").
  - [x] Client: Display friendly messages instead of raw error codes.
- [x] **4.3. CI/CD Pipeline:** Configure the hosting platform (Vercel/Netlify) and GitHub Actions to run tests and automatically deploy the application on every push to the `main` branch.
- [x] **4.4. Documentation:** Write clear `README.md` files for the repository, detailing the architecture, API endpoints, and setup process.
